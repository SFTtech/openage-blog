Title: Openage Development News: May 2024
Date: 2024-06-04
Tags: devlog, news, pathfinding, simulation
Authors: heinezen
Summary: Devlog for May 2024

- Pathfinding into game simulation
- took a bunch of smaller changes and tweaks

## Pathfinding in Game Simulation

We finally got flow field pathfinding implemented in the game simulation!
You can see the result below:

![]()

In the game simulation, not that much is being done beyond initializing
the flow field grids when loading a modpack (as discussed in [last month's](TODO)
post) and sending path requests from the movement system to the pathfinding
subcomponent. In the movement system, we only have to create the path request
consisting of grid ID (extracted from the moving game entity's `Move` ability),
start location (current position of the game entity), and target location
(position of the movement target). The request is forwarded to the
`Pathfinder` object referenced in the game state which acts as an
interface to the pathfinding subcomponent. After the pathfinding is finished,
the movement system gets back a list of waypoints which can then be
inserted into the game entity's movement curve.

While all of this sounds pretty simple *now*, there were still a bunch of
fixes necessary to the main pathfinding algorithms to make it work
properly. We will quickly go over the major problems that we faced
in the next sections.

### Diagonal Paths Blocking

When building a flow field, we want to point the vectors of each cell
in the direction of the path with the minimum movement cost. The naive
way of computing a direction vector for a cell in a flow field
is pretty simple: For each cell, we check the integration values for
the 8 surrounding neighbor cells and let the direction vector point
in the direction of the neighbor with the lowest value. Do that for all
the cells and the flow field is ready.

However, this solution is flawed in that it does not account for a specific
edge case concerning diagonal movement. You may be able to spot the problem
by looking at the example grid below.

![Naive cell comparison]()

*Hint: Check the direction vectors in the top corner.*

As you can see above, the problem here is that some diagonal paths at the top
should not be possible. It's as if the path would literally slips through
the cracks of the impassable cells. This behavior is cause by the naive
implementation considering all neighbor cells individually. However, logically
(or in AoE2 at least), a diagonal path should only be able to exist if an adjacent
horizontal *or* vertical cell are passable. If neither of them are, then the corresponding
diagonal cell should be considered "blocked".

The solution to this problem is actually pretty simple. We can find out which
neighbor cells should be considered "blocked" by processing the 4 vertical/horizontal
neighbor cells' integration values first and add an additional check that sets a flag
if they are impassable. Afterwards, we process the 4 diagonal cells where we now also
check whether their adjacent horizontal/vertical cells are impassable. If they both are
impassable, the diagonal cell is considered "blocked" and the integration value
comparison is skipped over.

The result then looks like this:

![Improved cell comparison]()

### Start/Target Sector Refinements

As previously explained in an [older devlog](TODO), the pathfinder executes in three stages:

1. High-level search: Search for a path on the *sector* level with A\* using the portals connecting each sector.
2. Low-level search: Build flow fields for all sectors in the sector path found by the high-level search.
3. Waypoint creation: Follow the direction vectors in the flow fields from start to target cell.

The reason we do stage 1 is to save computation time by only creating and building flow fields
for the sectors that are visited by the path.

Our initial implementation of the high-level pathfinder needed a few adjustments to work properly.
For example, one assumption was that if both the start and target cell of a path were in the same sector,
they were always reachable from the same sector and thus the high-level search could be skipped. However,
this didn't account for scenarios were start and target were separated by a wall, as seen in the example below:

![Naive grid]()

*The only way to reach the target (orange) from the start (green) is to go around through the neighboring sector on the left.*

Another wong assumption was that all portal of a sector can be reached from the start/target cells.
This is obviously not always the case, as you can also see in the example above: The start cell
only has access to the portals in the top left corner of the sector that it's located in. An even
more extreme example would be a start/target cell on an "island", i.e. it location is sorrounded
by impassable cells. If that happens, paths to other sectors obviously can't exist.

![Example ingame island]()

*Ingame example of how such an island could look like. Note that terrain is only one way of creating this situation. Being sorrounded by buildings would have the same effect.*

We are now avoiding these problems by first checking which portals are accessible from the start and
target cells are before starting the high-level pathfinder. To do this, we can simply integrate the
fields for the start and target sectors and then check for each sector portal whether the corresponding
cells in the integration field are passable. Accessible portals in the start sector become the starting
node set for the high-level A\* search, while the accessible portals in the target sector become the
goal nodes. We can even reuse the integration fields for the start and target sector for the low-level
calculations later, since we know that these sectors will be definitely visited. Therefore, these refinements
don't even create that much of an overhead.


### Propagating Line-of-sight through Portals

As described in our [April devlog](TODO), the pathfinder uses line-of-sight (LOS) optimization
to smooth pathing close to the target cell. To put it simply, when a cell on the grid is flagged as LOS,
there exist a direct path from this cell to the target. In practice, this means that game entities can travel
to the target waypoint in a straight line, once the path reaches a cell fagged as LOS.

Previously, LOS computatations stopped at the edges of the target sector. However,
this meant that whenever a path would cross sector boundaries, there was a chance that it
looked noticeable weird. Instead of bee-lining straight towards the target when there are
no obstructions, game entities would first move to the edge of the target sector. This often
looked as if the entities were avoiding invisible obstacles.

![Non-LOS example]()

This behaviour has been fixed by propagating the LOS flags of cells through the portal path.
In essence, the LOS flags from the already integrated (entry) side of a portal are passed through to
the other (exit) side. LOS integration is then run with the LOS flagged portal cells as the starting
point. As a result, paths look much better when they cross multiple sectors:

![LOS propagation]()


### Optimizing Field Generation

This topic came up in a Reddit comment before, so we thought it might be interesting to pick it up
again. Performance is also a big factor in the feasibility of flow fields for fast-paced RTS gameplay.
While flow fields can result in overall smoother paths, the added complexity can come with a hefty
performance price tag. Thus, we have to ensure that the pathfinding is as performant as possible to
still work in real game situations.

Over the past months, we have applied several optimization strategies:

**Simplified Code**

We removed a lot of redundant code from the design phase of the pathfinder. This includes things
like redundant sanity checks, debug code, or flags that were only relevant for the pathfinding
demos that you see in our motnhly devlogs.

**CPU-friendly datastructures**

To increase throughput for field generation on the CPU, we replaced most occurences of datastructures
that are known to be slow (e.g. `std::unordered_map`, `std::deque`, `std::unordered_set`) with
vectorized data types (`std::vector` and `std::array`). These data types utilize the CPU's L1-L3 caches
much better, which means that the CPU has to spend less time on fetching data from RAM and has more
time for running calculations.

**Flow Field Caching**

Generated flow fields are now cached and reused for subsequent path requests if possible. The reason
why this works at all is that field generation is deterministic. Choosing the same target cells
used in a previous generation will result in the same flow field. A common scenario where this can
happen is when the target cells are associated with a portal to another sector. Paths that take
the same portal can then also reuse the same flow field.

----

The overall result of our optimizations is that field generation is now about 2x-4x faster than
the first iteration of the pathfinder, even including the enhancements we discussed before. Field
generation is now so fast even that the A\* calculations of the high-level pathfinder take
more time than all low-level pathfinding calculations combined!

## Frustum Culling




## What's next?

- definitly enough pathfinding for now
- we'll continue with something more relaxing

## Questions?

Any more questions? Let us know and discuss those ideas by visiting [our subreddit /r/openage](https://reddit.com/r/openage)!

As always, if you want to reach us directly in the dev chatroom:

* Matrix: `#sfttech:matrix.org`

Title: Openage Development News: May 2024
Date: 2024-06-04
Tags: devlog, news, pathfinding, simulation
Authors: heinezen
Summary: Devlog for May 2024

- Pathfinding into game simulation
- took a bunch of smaller changes and tweaks

## Pathfinding in Game Simulation

We finally got flow field pathfinding implemented in the game simulation!
You can see the result below:

![Game simulation with pathfinding]()

In the game simulation, not that much is being done beyond initializing
the flow field grids when loading a modpack (as discussed in [last month's](TODO)
post) and sending path requests from the movement system to the pathfinding
subcomponent. In the movement system, we only have to create the path request
consisting of grid ID (extracted from the moving game entity's `Move` ability),
start location (current position of the game entity), and target location
(position of the movement target). The request is forwarded to the
`Pathfinder` object referenced in the game state which acts as an
interface to the pathfinding subcomponent. After the pathfinding is finished,
the movement system gets back a list of waypoints which can then be
inserted into the game entity's movement curve.

While all of this sounds pretty simple *now*, there were still a bunch of
fixes necessary to the main pathfinding algorithms to make it work
properly. We will quickly go over the major problems that we faced
in the next sections.

### Diagonal Paths Blocking

When building a flow field, we want to point the vectors of each cell
in the direction of the path with the minimum movement cost. The naive
way of computing a direction vector for a cell in a flow field
is pretty simple: For each cell, we check the integration values for
the 8 surrounding neighbor cells and let the direction vector point
in the direction of the neighbor with the lowest value. Do that for all
the cells and the flow field is ready.

However, this solution is flawed in that it does not account for a specific
edge case concerning diagonal movement. You may be able to spot the problem
by looking at the example grid below.

![Naive cell comparison]()

*Hint: Check the direction vectors in the top corner.*

As you can see above, the problem here is that some diagonal paths at the top
should not be possible. It's as if the path would literally slips through
the cracks of the impassable cells. This behavior is cause by the naive
implementation considering all neighbor cells individually. However, logically
(or in AoE2 at least), a diagonal path should only be able to exist if an adjacent
horizontal *or* vertical cell are passable. If neither of them are, then the corresponding
diagonal cell should be considered "blocked".

The solution to this problem is actually pretty simple. We can find out which
neighbor cells should be considered "blocked" by processing the 4 vertical/horizontal
neighbor cells' integration values first and add an additional check that sets a flag
if they are impassable. Afterwards, we process the 4 diagonal cells where we now also
check whether their adjacent horizontal/vertical cells are impassable. If they both are
impassable, the diagonal cell is considered "blocked" and the integration value
comparison is skipped over.

The result then looks like this:

![Improved cell comparison]()

### Start/Target Sector Refinements

As previously explained in an [older devlog](TODO), the pathfinder executes in three stages:

1. High-level search: Search for a path on the *sector* level with A\* using the portals connecting each sector.
2. Low-level search: Build flow fields for all sectors in the sector path found by the high-level search.
3. Waypoint creation: Follow the direction vectors in the flow fields from start to target cell.

The reason we do stage 1 is to save computation time by only creating and building flow fields
for the sectors that are visited by the path.

In the inital implementation of stage 1, there were a few bugs that have to be ironed out. For example,
one (wrong) assumption we made was that a start or target cell would automatically have access to all
portals in their sector. There are some obvious counterexamples, e.g. when the start is on an island:

![Example ingame island]()

*Ingame example of how such an island could look like. Note that terrain is only one way of creating this situation. Sorrounding the game entity with buildings would have the same effect.*

In the situation shown above, we cannot even exit the sector and are confined to the island. Another
example would be a situation where only partial access to portals exist:

![Naive grid]()

*Start cell (green) and target cell (orange) have access to different portals, even though they are in the same sector. The only way to reach the target from the start is to path through the portals to the neighboring sector on the left.*

To avoid these problems, the pathfinder is now doing a preliminary check before the high-level search
that determines which portals are accessible by the start cell and the target cell, respectively. This
is done by calculating their sectors' integration fields and checking which portals are passable
in said integration fields¹. When the A\* algorithm in the high-level search is started, we use the
portals reachable from the start sector as the starting nodes. The portals reachable by the target
cell become possible end nodes.

¹ We can reuse these fields in stage 2 (low-level search) when building the flow fields for
these sectors. Thus, it isn't even much of an overhead.


### Propagating Line-of-sight through Portals

As described in our [April devlog](TODO), the pathfinder uses line-of-sight (LOS) optimization
to improve pathing close to the target cell. To put it simply: When a cell on the grid is flagged as LOS,
there exist a direct (non-obstructed) path from this cell to the target. In practice, this
means that any game entity at the position of this cell can move to the target position in
a straight line. This makes pathing look much more natural and *smooth*. If we would
only use the direction vectors of the flow field right until the end, we would
be limited to their 8 possible directions.

In our initial implementation, LOS optimization was confined to the target sector, i.e.
cells outside the target sector were never flagged as LOS. However, this meant that a lot
of paths that could have been a straight line but crossed a sector boundary looked
noticeably weird. Instead of bee-lining straight towards the target when there are
no obstructions, game entities would have to move to the edge of the target sector first
before they would reach an LOS cell:

![Non-LOS example]()

*You can almost see where the sector boundary is as the game entity is turning very sharply towards the target as it reaches the first LOS flagged cell in the target sector.*

This behaviour has been fixed by propagating the LOS integration through sector portals.
Essentially, LOS flags are passed from one side of the portal (in the entry sector) to the
other (in the exit sector). LOS integration then continues in the exit sector using the passed LOS flagged
cells as the starting point. As a result, paths look much better when they cross multiple sectors:

![LOS propagation]()


### Optimizing Field Generation

The topic of performance came up in a Reddit comment before, so we thought it might be interesting to pick it up
again. Performance is big factor in the feasibility of flow fields, since pathfinding should not
stall gameplay operations. Flow fields do have some benefits for the quality of paths, but the added
complexity can come with a hefty performance price tag. Thus, we have to ensure that the pathfinding
is still as performant as possible.

Over the last month, we have applied several optimization strategies:

**Simplified Code**

We removed a lot of redundant code from the design phase of the pathfinder. This includes things
like redundant sanity checks, debug code, or flags that were only relevant for the pathfinding
demos that you've seen in our monthly devlogs.

**CPU-friendly datastructures**

To increase throughput for field generation on the CPU, we replaced most occurences of datastructures
that are known to be slow (e.g. `std::unordered_map`, `std::deque`, `std::unordered_set`) with
vectorized data types (`std::vector` and `std::array`). These data types utilize the CPU's L1-L3 caches
much better, which means that the CPU has to spend less time on fetching data from RAM and has more
time for running calculations.

**Flow Field Caching**

Generated flow fields are now cached and reused for subsequent path requests if possible.
In practice, chaching can be done for all flow fields on the high-level path where the target
is a portal cell (i.e. any sector that is not the target sector). Since field
generation is deterministic, building two flow fields with the same target cell results
in them being equal. Therefore, if a high-level paths uses the same portal as a previous
path request, the previously generated flow field can be reused.

----

The overall result of our optimizations is that pathfinding is now about 2x-4x faster than
in our first iteration. Technically, there are no benchmarks yet, so you have to trust our numbers
for now. On our test machines, a path request can take between `0.3ms` and `2ms` for paths
of roughly the same length, depending on the number of fields that have to be built and
how many obtructions there are per sector. Flow field and integration field generation
in the low-level pathfinding stage is now so fast that the A\* calculations of the
high-level pathfinder are becoming the bottleneck with ~50% runtime usage.

## Frustum Culling

- contribution by an external contributor
  - optimization for the renderer
  - frustum culling: only render objects that are in view of the camera
    - e.g. 200 objects in view vs. 10000 on map
    - that's a lot of objects that can potentially be skipped

- implementation:
  - get frustum from camera
    - imagine it as a box with one side being the game window
    - extending into the scene displayed by the renderer
  - for each rendered object, check if its position is in the box
  - if it's not in the box, don't render it


## What's next?

That was definitely enough pathfinding for a while. There is a probably still lot to improve,
but other parts of the engine need attention too.

Next month, we will focus more on game entity *interactions*. That means we will make them do
things to each other, like damage or healing or whatever we can think about that's fun (and
not too complicated).

## Questions?

Any more questions? Let us know and discuss those ideas by visiting [our subreddit /r/openage](https://reddit.com/r/openage)!

As always, if you want to reach us directly in the dev chatroom:

* Matrix: `#sfttech:matrix.org`
